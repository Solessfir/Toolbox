// Copyright Solessfir. All Rights Reserved.

#include "K2Node_Test.h"
#include "KismetCompiler.h"
#include "K2Node_CallFunction.h"
#include "BlueprintNodeSpawner.h"
// #include "Kismet2/BlueprintEditorUtils.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "ToolboxConfigFunctionLibrary.h"
#include "Kismet2/WildcardNodeUtils.h"

// used to add pins for node
void UK2NodeTest::AllocateDefaultPins()
{
    Super::AllocateDefaultPins();
    
    // Exec Input
    CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);

    // Config Enum Input

    // FCreatePinParams InPinParams;
    // UEdGraphPin* ConfigFilePin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Enum, ConfigFilePinName, InPinParams);
    // ConfigFilePin->AutogeneratedDefaultValue = GEngineIni;
    // ConfigFilePin->DefaultValue = GEngineIni;


    // Find the Enum type for the pin
    
    // GConfig->GetFloat(*SectionName, *PropertyName, StringValue, IniNameLookupMap.FindChecked(ConfigFile));

    // UEnum::GetValueAsString()
    if (UEnum* EnumType = FindObject<UEnum>(nullptr, TEXT("EConfigIniFileNames"), true))
    {
        // Create a new pin with the Enum type
        
        UEdGraphPin* EnumPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Byte, NAME_None);
        
        EnumPin->PinType.PinSubCategoryObject = EnumType;

        // Set a friendly name for the pin
        EnumPin->PinFriendlyName = FText::FromString(TEXT("Select Option"));

        // Optionally set default value
        EnumPin->DefaultValue = EnumType->GetNameStringByIndex(0);
    }


    

    // Exec Output
    CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);

    UEdGraphPin* WildcardPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, NAME_None);
    WildcardPin->bNotConnectable = false;
    
   //  FWildcardNodeUtils::CreateWildcardPin(this, UEdGraphSchema_K2::PN_ReturnValue, EGPD_Output);

    //const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    
    // int data pin
    // const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    // UEdGraphPin* IntPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Int, IntPinName);
    // K2Schema->ConstructBasicPinTooltip(*IntPin, INVTEXT("Int Test Input Pin"), IntPin->PinToolTip);
    // IntPin->DefaultValue = FString::FromInt(NodeNumber);
}

// core method, during compilation will generate resulting data
void UK2NodeTest::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    Super::ExpandNode(CompilerContext, SourceGraph);

    // Access to the blueprint where this node has been called
    // UBlueprint* BP = FBlueprintEditorUtils::FindBlueprintForGraph(SourceGraph);
    // ensure(BP);
    // if (BP != nullptr)
    // {
    //     // do some logics here
    // }

    if (const UEdGraphPin* ConfigFilePin = FindPin(ConfigFilePinName))
    {
        UE_LOG(LogTemp, Warning, TEXT("UK2NodeTest::ExpandNode -> ConfigFile Pin Value is %s"), *ConfigFilePin->GetDefaultAsString())
    }
    
   // UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);
   // /** FUNCTION CALL HERE --------------------------------------------------------------------------------------------------------->*/
   // CallFunction->FunctionReference.SetExternalMember(GET_FUNCTION_NAME_CHECKED(UToolboxConfigFunctionLibrary, LogNumber), UToolboxConfigFunctionLibrary::StaticClass());
   // /** FUNCTION CALL HERE --------------------------------------------------------------------------------------------------------->*/
   // CallFunction->AllocateDefaultPins();


    
    
    // connect IntPin of editor k2 node (this) to runtime function node's Number pin
    // UEdGraphPin* TargetIntPin = CallFunction->FindPinChecked(TEXT("Number"));
    // CompilerContext.CopyPinLinksToIntermediate(*IntPin, *TargetIntPin); // copy data from editor pin
    // 
    // // move Exec and Then pin addreses from editor node to runtime function node
    // CompilerContext.MovePinLinksToIntermediate(*GetExecPin(), *(CallFunction->GetExecPin()));
    // CompilerContext.MovePinLinksToIntermediate(*GetThenPin(), *(CallFunction->GetThenPin()));
    
    // since all connections from this node are forwarded to CallFunction
    // we should disconnect the rest, if any
    // why? because this node will not exist in runtime build
    // in runtime only CallFunction node will exist
    // this is how K2 works, it just replaces one node with another or group of another nodes with some logic
    // since this script is short, here we do only very basic logic of forwarding data, it can be much more complex
    BreakAllNodeLinks();
}

// will be called during compilation. Allows to perform validation of internal values
void UK2NodeTest::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);
}

// used to place this node into add blueprint node popup
void UK2NodeTest::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    Super::GetMenuActions(ActionRegistrar);

    // simple, classic way of working
    // UClass* Action = GetClass();
    // if (ActionRegistrar.IsOpenForRegistration(Action))
    // {
    //     UBlueprintNodeSpawner* Spawner = UBlueprintNodeSpawner::Create(GetClass());
    //     check(Spawner != nullptr);
    //     ActionRegistrar.AddBlueprintAction(Action, Spawner);
    // }
    
    // Lambda used to sync settings between spawned K2 nodes of this type
    TFunction<void(UEdGraphNode*, bool, int32)> SetupNodeData = [](UEdGraphNode* NewNode, bool bIsTemplateNode, int32 NodeNumber)
    {
        UK2NodeTest* MenuNode = CastChecked<UK2NodeTest>(NewNode);
        MenuNode->NodeNumber  = NodeNumber; // set new node's internal value
    };
    
    UClass* NodeClass = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(NodeClass))
    {
        // as example - register 3 nodes of UK2NodeTest type
        for (int32 Index = 0; Index < 1; Index++)
        {
            UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(NodeClass);
            check(NodeSpawner != nullptr);
            NodeSpawner->CustomizeNodeDelegate = UBlueprintNodeSpawner::FCustomizeNodeDelegate::CreateLambda(SetupNodeData, Index);
            ActionRegistrar.AddBlueprintAction(NodeClass, NodeSpawner);
        }
    }
}

// will set node category in add blueprint node popup
FText UK2NodeTest::GetMenuCategory() const
{
    if (NodeNumber == 0)
    {
        return INVTEXT("TestK2Node|1");
    }
    
    if (NodeNumber == 1)
    {
        return INVTEXT("TestK2Node|2");
    }
    
    if (NodeNumber == 2)
    {
        return INVTEXT("TestK2Node|3");
    }
    
    // default
    return INVTEXT("TestK2Node");
}

// node corner icon
FName UK2NodeTest::GetCornerIcon() const
{
    //return TEXT("Graph.Latent.LatentIcon");

    return NAME_None;
    // return TEXT("FontEditor.UpdateAll");
}

// used to add node title color
FLinearColor UK2NodeTest::GetNodeTitleColor() const
{
    return Super::GetNodeTitleColor();
    // return FLinearColor::Blue;
}

// used to generate node title
FText UK2NodeTest::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return INVTEXT("Access to Config");
    // return FText::Format(INVTEXT("TestNode {0}"), NodeNumber);
}

// for tooltip
FText UK2NodeTest::GetTooltipText() const
{
    return FText::Format(INVTEXT("This is test K2 Node Tooltip. NodeNumber is = {0}."), NodeNumber);
}

// for icon and tint
FSlateIcon UK2NodeTest::GetIconAndTint(FLinearColor& OutColor) const
{
    static const FSlateIcon Icon = FSlateIcon(FAppStyle::GetAppStyleSetName(), "GraphEditor.K2Node_CallFunction");
    return Icon;
}

// true if compatible with selected blueprint editor graph
bool UK2NodeTest::IsCompatibleWithGraph(UEdGraph const* Graph) const
{
    // This is the default Actor Editor Graph
    if (Graph->GetSchema()->GetGraphType(Graph) == GT_Ubergraph)
    {
        // UBlueprint* Blueprint = FBlueprintEditorUtils::FindBlueprintForGraph(Graph);
        // UEdGraphSchema_K2 const* K2Schema = Cast<UEdGraphSchema_K2>(Graph->GetSchema());

        // prevent placement of this node in Construction Script
        return !UEdGraphSchema_K2::IsConstructionScript(Graph);
    }
    
    return false;
}

FBlueprintNodeSignature UK2NodeTest::GetSignature() const
{
    return Super::GetSignature();
}

void UK2NodeTest::GetNodeContextMenuActions(UToolMenu* Menu, UGraphNodeContextMenuContext* Context) const
{
    Super::GetNodeContextMenuActions(Menu, Context);

    // if (Context->Node != nullptr && Context->Pin == nullptr) // we are in Node context
    // {
    //     // lambda to reset exec pins list
    //     TFunction<void()> ClearExecPins = [this]()
    //     {
    //         // remove const modifiers
    //         // "this" lambda modifier is const so get rid of constness as well
    //         UK2NodeTest* OwningNode = const_cast<UK2NodeTest*>(this);
    //         // validation
    //         if (OwningNode == nullptr) return;
    //
    //         OwningNode->RemoveMultiplePinsByNames(&OwningNode->ExecPinsCache);
    //         OwningNode->ExecPinsCache.Empty(); // clear array of pins
    //     };
    //     
    //     // lambda to add another exec pin
    //     TFunction<void()> AddExecPin =
    //         [this]() -> void {
    //         // remove const modifiers
    //         // "this" lambda modifier is const so get rid of constness as well
    //         UK2NodeTest* OwningNode = const_cast<UK2NodeTest*>(this);
    //         // validation
    //         if (OwningNode == nullptr) return;
    //         OwningNode->ExecPinsCache.Add(GetNextExecPinName());
    //         OwningNode->GenerateExecPins();
    //         OwningNode->ReconstructNode(); // toggle reconstruction
    //     };
    //     // add menu section for our items
    //     FToolMenuSection& Section = Menu->AddSection("TypeOperations", LOCTEXT("UK2NodeTest", "Type Operations"));
    //     // add exec pin
    //     Section.AddMenuEntry(
    //         FName("AddExecPin"),
    //         LOCTEXT("UK2NodeTest", "Add Exec Pin"),
    //         LOCTEXT("UK2NodeTest", "Will add Exec Pin to Node"),
    //         FSlateIcon(),
    //         FUIAction(FExecuteAction::CreateLambda(AddExecPin))
    //     );
    //     // reset exec pins
    //     Section.AddMenuEntry(
    //         FName("ClearExecPins"),
    //         LOCTEXT("UK2NodeTest", "Clear Exec Pins"),
    //         LOCTEXT("UK2NodeTest", "Will clear all Exec Pins"),
    //         FSlateIcon(),
    //         FUIAction(FExecuteAction::CreateLambda(ClearExecPins))
    //     );
    // }
    // else
    // if (Context->Pin != nullptr) // we are in Pin context
    // {
    //     // lambda to reset wildcard pin types
    //     // *note args should be const or it won't compile
    //     TFunction<void()> ClearPins =
    //     [this]() -> void {
    //         // remove const modifiers
    //         // "this" lambda modifier is const so get rid of constness as well
    //         UK2NodeTest* OwningNode = const_cast<UK2NodeTest*>(this);
    //         // validation
    //         if(OwningNode == nullptr) return;
    //         // reset all pins
    //         for (UEdGraphPin* Pin : OwningNode->Pins) {
    //             if (Pin->PinName == UK2NodeTest::WcInputPinName
    //                 || Pin->PinName == UK2NodeTest::WcOutputPinName
    //             ) {
    //                 // reset pin type
    //                 OwningNode->ResetWcPinType(Pin);
    //             }
    //         }
    //         OwningNode->CurrentWcType = {}; // reset current pin type cache
    //         OwningNode->ReconstructNode(); // toggle reconstruction
    //     };
    //     // lambda to set type for given pin
    //     // *note args should be const or it won't compile
    //     TFunction<void(const FKeyValuePinType)> ApplyPinType =
    //     [this](const FKeyValuePinType Type) -> void {
    //         // remove const modifiers
    //         // "this" lambda modifier is const so get rid of constness as well
    //         UK2NodeTest* OwningNode = const_cast<UK2NodeTest*>(this);
    //         // validation
    //         if (OwningNode == nullptr) return;
    //         OwningNode->CurrentWcType = Type;
    //         OwningNode->ApplyAllWcPinsToType(Type.Key, Type.Value);
    //         OwningNode->ReconstructNode(); // toggle reconstruction
    //     };
    //     // add menu section for our items
    //     FToolMenuSection& Section = Menu->AddSection("TypeOperations", LOCTEXT("UK2NodeTest", "Type Operations"));
    //     // add items to work with wildcard pins
    //     if (Context->Pin->PinName == UK2NodeTest::WcInputPinName
    //         && Context->Pin->Direction == EGPD_Input
    //     ) {
    //         // iterate thru all accessible types and generate menu items
    //         for (TPair<FName, FKeyValuePinType> Item : WcAllowedTypes) {
    //             Section.AddMenuEntry(
    //                 Item.Key, // make FName menu item identifier from combined string
    //                 FText::FromString(FString::Printf(TEXT("Set Pin Type to %s"), *Item.Key.ToString())), // menu item name
    //                 FText::Format(LOCTEXT("UK2NodeTest", "Will convert Pin type to {0} Type"), FText::FromString(Item.Key.ToString())),
    //                 FSlateIcon(),
    //                 // FExecuteAction::CreateUObject requires const function or const uobject refrence. Why? .... ask devs
    //                 // just use const_cast to add or remove constness of variables,
    //                 // maybe, in future, this will be fixed, who knows...
    //                 // *note: i decided to use lambda instead
    //                 //FUIAction(FExecuteAction::CreateUObject(const_cast<UK2NodeTest*>(this), &UK2NodeTest::SetWcPinType, Context->Pin, Item.Value.Key, Item.Value.Value))
    //                 FUIAction(FExecuteAction::CreateLambda(ApplyPinType, Item.Value))
    //             );
    //         }
    //         // add reset type
    //         Section.AddMenuEntry(
    //             FName("ResetPinType"),
    //             LOCTEXT("UK2NodeTest", "Reset Pin Type"),
    //             LOCTEXT("UK2NodeTest", "Will reset Wildcard Pin type"),
    //             FSlateIcon(),
    //             FUIAction(FExecuteAction::CreateLambda(ClearPins))
    //         );
    //     }
    // }
}

void UK2NodeTest::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
    // When a connection is made, resolve the wildcard pin type to match the connected pin
    if (Pin && Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard)
    {
        if (Pin->LinkedTo.Num() > 0)
        {
            UEdGraphPin* ConnectedPin = Pin->LinkedTo[0];
            Pin->PinType = ConnectedPin->PinType;  // Resolve the type based on the connected pin
        }
    }

    Super::NotifyPinConnectionListChanged(Pin);
}
